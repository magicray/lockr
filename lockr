#!/usr/bin/env python
import os
import ssl
import time
import json
import socket
import struct
import select
import hashlib
import optparse
from OpenSSL import crypto


class EPollLoop(object):
    def __init__(self, port, servers):
        key = crypto.PKey()
        key.generate_key(crypto.TYPE_RSA, 1024)
        cert = crypto.X509()
        cert.gmtime_adj_notBefore(0)
        cert.gmtime_adj_notAfter(30*24*60*60)
        cert.set_pubkey(key)
        cert.sign(key, 'sha1')

        with open('cert', 'w') as fd:
            fd.write(crypto.dump_certificate(crypto.FILETYPE_PEM, cert))
        with open('key', 'w') as fd:
            fd.write(crypto.dump_privatekey(crypto.FILETYPE_PEM, key))

        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.sock.bind(('0.0.0.0', port))
        self.sock.listen(5)
        self.sock.setblocking(0)

        self.epoll = select.epoll()
        self.epoll.register(self.sock.fileno(), select.EPOLLIN)

        self.servers = servers
        self.connections = dict()
        self.stats = dict(in_pkt=0, in_bytes=0, out_pkt=0, out_bytes=0,
                          srv_accept=0, srv_established=0, srv_disconnect=0,
                          cli_connect=0, cli_established=0, cli_disconnect=0)

    def run(self):
        while True:
            for fileno, event in self.epoll.poll():
                if self.sock.fileno() == fileno:
                    sock, addr = self.sock.accept()
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                    self.stats['srv_accept'] += 1
                    sock.setblocking(0)
                    sock = ssl.wrap_socket(sock,
                                           keyfile='key',
                                           certfile='cert',
                                           do_handshake_on_connect=False,
                                           server_side=True)
                    self.connections[sock.fileno()] = dict(
                        sock=sock,
                        is_server=True,
                        handshake_done=False,
                        peer=sock.getpeername())
                    self.epoll.register(sock.fileno(), select.EPOLLIN)
                    continue

                try:
                    conn = self.connections[fileno]

                    if False == conn['handshake_done']:
                        if getattr(conn['sock'], 'do_handshake', None) is None:
                            conn['sock'] = ssl.wrap_socket(
                                conn['sock'],
                                do_handshake_on_connect=False,
                                server_side=False)

                        try:
                            conn['sock'].do_handshake()
                            conn['handshake_done'] = True
                            if 'handler' in conn:
                                self.epoll.modify(fileno, select.EPOLLOUT)
                            else:
                                self.epoll.modify(fileno, select.EPOLLIN)
                        except ssl.SSLError as e:
                            if ssl.SSL_ERROR_WANT_READ == e.errno:
                                self.epoll.modify(fileno, select.EPOLLIN)
                            elif ssl.SSL_ERROR_WANT_WRITE == e.errno:
                                self.epoll.modify(fileno, select.EPOLLOUT)
                            else:
                                raise
                        continue

                    if event & select.EPOLLIN:
                        result = select.EPOLLIN
                        if 'handler' not in conn:
                            read_bytes = 1
                        elif 'in_size' not in conn:
                            read_bytes = conn['in_hdr_size']
                        else:
                            read_bytes = conn['in_size']

                        try:
                            buf = conn['sock'].recv(read_bytes)
                            self.stats['in_bytes'] += len(buf)
                        except Exception as e:
                            self.epoll.modify(fileno, select.EPOLLIN)
                            continue

                        if 0 == len(buf):
                            raise Exception('recv returned zero bytes')

                        if 'handler' not in conn:
                            proto = struct.unpack('!B', buf)[0]
                            conn['handler'] = self.servers[proto]()
                            conn['in_hdr_size'] = 4
                            conn['in_hdr_pkts'] = list()
                            log('accepted {0}'.format(conn['peer']))
                            self.stats['srv_established'] += 1
                            result = conn['handler'].on_accept(conn['peer'])
                        elif 'in_size' not in conn:
                            conn['in_hdr_pkts'].append(buf)
                            conn['in_hdr_size'] -= len(buf)
                            if 0 == conn['in_hdr_size']:
                                size = struct.unpack(
                                    '!I',
                                    ''.join(conn['in_hdr_pkts']))[0]
                                if 0 == size:
                                    self.stats['in_pkt'] += 1
                                    result = conn['handler'].on_recv('')
                                else:
                                    conn['in_size'] = size
                                    conn['in_pkts'] = list()
                                conn['in_hdr_size'] = 4
                                conn['in_hdr_pkts'] = list()
                        else:
                            conn['in_pkts'].append(buf)
                            conn['in_size'] -= len(buf)
                            if 0 == conn['in_size']:
                                pkt = ''.join(conn['in_pkts'])
                                del(conn['in_size'])
                                del(conn['in_pkts'])
                                self.stats['in_pkt'] += 1
                                result = conn['handler'].on_recv(pkt)

                    elif event & select.EPOLLOUT:
                        result = select.EPOLLOUT
                        if 'out_pkt' not in conn:
                            if 'peer' not in conn:
                                proto = struct.pack(
                                    '!B',
                                    conn['handler'].conn['proto'])
                                if 1 == conn['sock'].send(proto):
                                    conn['peer'] = conn['sock'].getpeername()
                                    conn['in_hdr_size'] = 4
                                    conn['in_hdr_pkts'] = list()
                                    log('connected {0}'.format(conn['peer']))
                                    self.stats['cli_established'] += 1
                                    self.stats['out_bytes'] += 1
                                    result = conn['handler'].on_connect()
                                else:
                                    log('unexpected code path')
                                    exit(0)
                            else:
                                self.stats['out_pkt'] += 1
                                result = conn['handler'].on_send()
                        else:
                            if 4 != conn['out_hdr_sent']:
                                if 'snd_hdr' not in conn:
                                    pkt = conn['out_hdr']
                                    offset = conn['out_hdr_sent']
                                    conn['snd_hdr'] = pkt[offset:]

                                n = conn['sock'].send(conn['snd_hdr'])
                                if n > 0:
                                    del(conn['snd_hdr'])
                                    conn['out_hdr_sent'] += n
                                    self.stats['out_bytes'] += n
                            else:
                                pkt = conn['out_pkt']
                                if len(pkt) > conn['out_sent']:
                                    if 'snd_pkt' not in conn:
                                        offset = conn['out_sent']
                                        conn['snd_pkt'] = pkt[offset:]

                                    n = conn['sock'].send(conn['snd_pkt'])
                                    if n > 0:
                                        del(conn['snd_pkt'])
                                        conn['out_sent'] += n
                                        self.stats['out_bytes'] += n
                                else:
                                    del(conn['out_sent'])
                                    del(conn['out_hdr_sent'])
                                    del(conn['out_hdr'])
                                    del(conn['out_pkt'])
                                    self.stats['out_pkt'] += 1
                                    result = conn['handler'].on_send()
                    else:
                        raise Exception('unhandled event({0})'.format(event))

                    if result in (select.EPOLLIN, select.EPOLLOUT):
                            self.epoll.modify(fileno, result)
                    elif result is not False:
                        if result is True:
                            self.epoll.modify(fileno, select.EPOLLIN)
                        else:
                            conn['out_pkt'] = result
                            conn['out_hdr'] = struct.pack('!I', len(result))
                            conn['out_sent'] = 0
                            conn['out_hdr_sent'] = 0
                            self.epoll.modify(fileno, select.EPOLLOUT)

                except Exception as e:
                    conn = self.connections[fileno]
                    del(self.connections[fileno])
                    self.epoll.unregister(fileno)
                    conn['sock'].close()
                    if conn['is_server']:
                        self.stats['srv_disconnect'] += 1
                    else:
                        self.stats['cli_disconnect'] += 1
                    if 'peer' in conn:
                        log('disconnected peer{0} reason({1})'.format(
                            conn['peer'], str(e)))
                    if 'handler' in conn:
                        if conn['handler'].on_close() is True:
                            self.connect(conn['handler'])

    def connect(self, handler):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
        s.setblocking(0)
        self.connections[s.fileno()] = dict(
            sock=s,
            handshake_done=False,
            is_server=False,
            handler=handler)
        self.epoll.register(s.fileno(), select.EPOLLOUT)
        try:
            self.stats['cli_connect'] += 1
            s.connect((handler.conn['ip'], handler.conn['port']))
        except Exception as e:
            if 115 != e.errno:
                raise


def log(msg):
    timestamp = time.time()
    os.write(2, '{0}.{1} : {2}\n'.format(
        time.strftime('%y%m%d.%H%M%S', time.gmtime(timestamp)),
        '%06d' % ((timestamp - int(timestamp)) * 10**6),
        msg))


class StatsServer():
    def on_accept(self, peer):
        return True

    def on_recv(self, buf):
        return json.dumps(my_state)

    def on_send(self):
        return True

    def on_close(self):
        pass


class StatsClient():
    def __init__(self, conn):
        self.conn = conn
        self.key = (conn['ip'], conn['port'])

    def on_connect(self):
        return ''

    def on_recv(self, buf):
        peer_state[self.key] = json.loads(buf)
        return ''

    def on_send(self):
        return True

    def on_close(self):
        peer_state[self.key] = None
        return True


class LockrServer():
    def on_accept(self, peer):
        return True

    def on_recv(self, buf):
        cmd = struct.unpack('!B', buf[0])[0]
        res = ''

        if 0 == cmd:
            state = dict()
            for ip, port in peer_state:
                state['{0}:{1}'.format(ip, port)] = peer_state[(ip, port)]

            res = json.dumps(dict(
                my_state=my_state,
                peer_state=state,
                timestamp=time.strftime('%y%m%d.%H%M%S', time.gmtime())))
        elif 1 == cmd:
            docs = dict()
            i = 1
            while i < len(buf):
                key = buf[i:i+32]
                file = struct.unpack('!I', buf[i+32:i+36])[0]
                offset = struct.unpack('!I', buf[i+36:i+40])[0]
                length = struct.unpack('!I', buf[i+40:i+44])[0]
                i += 44 + length
                docs[key] = (file, offset, length)

            assert (len(docs)*44 + sum(map(lambda x: docs[x][2], docs)) ==
                    len(buf)-1), 'invalid put request'

            lockrdata.write_txn(buf[1:])
            return json.dumps('ok')

        return res

    def on_send(self):
        return True

    def on_close(self):
        pass


class Lockr(object):
    def __init__(self, servers):
        self.servers = servers
        self.sock = self.connect()

    def connect(self):
        for ip, port in self.servers:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock = ssl.wrap_socket(sock)
                sock.connect((ip, port))
                sock.send(struct.pack('!B', 200))
                return sock
            except:
                pass
        raise Exception('could not connect to server')

    def request(self, buf):
        def recv(length):
            pkt = list()
            while length > 0:
                pkt.append(self.sock.recv(length))
                if 0 == len(pkt[-1]):
                    raise Exception('connection closed')
                length -= len(pkt[-1])
            return ''.join(pkt)

        self.sock.sendall(struct.pack('!I', len(buf)))
        self.sock.sendall(buf)

        return recv(struct.unpack('!I', recv(4))[0])

    def get_state(self):
        return json.loads(self.request(struct.pack('!B', 0)))

    def put(self, docs):
        items = [struct.pack('!B', 1)]
        for k, v in docs.iteritems():
            items.append(hashlib.sha256(k).digest())
            items.append(struct.pack('!II', v[0]/(2**32), v[0] % (2**32)))
            items.append(struct.pack('!I', len(v[1])))
            items.append(v[1])

        return self.request(''.join(items))


class LockrData(object):
    def __init__(self):
        self.check()

    def check(self):
        if not os.path.isdir('data'):
            os.mkdir('data')

        files = sorted(filter(lambda f: 8 == len(f) and int(f, 16),
                              os.listdir('data')))

    def write_txn(self, buf):
        buf_len = struct.pack('!I', len(buf))
        buf_md5 = hashlib.md5('xyz').digest()
        os.write(self.fd, ''.join([buf_len, buf, buf_md5]))


if '__main__' == __name__:
    parser = optparse.OptionParser()
    parser.add_option('--port', dest='port', type='int')
    parser.add_option('--cmd', dest='cmd', type='string')
    parser.add_option('--servers', dest='servers', type='string')
    opt, args = parser.parse_args()

    servers = set()
    if opt.servers:
        servers = set(map(lambda x: (socket.gethostbyname(x[0]), int(x[1])),
                          map(lambda x: x.split(':'),
                              opt.servers.split(','))))

    if opt.port:
        os.dup2(os.open(
            'log.{0}'.format(time.strftime('%y%m%d', time.gmtime())),
            os.O_CREAT | os.O_WRONLY | os.O_APPEND), 2)

        lockrdata = LockrData()

        peer_state = dict((ip_port, None) for ip_port in servers)

        app = EPollLoop(opt.port, {100: StatsServer, 200: LockrServer})

        for peer in peer_state:
            app.connect(StatsClient(dict(ip=peer[0], port=peer[1], proto=100)))

        my_state = dict(
            file_a=0,
            file_y=0,
            size_y=0,
            file_z=0,
            size_z=0,
            committed=0,
            peer_count=0,
            stats=app.stats)

        app.run()
    else:
        cli = Lockr(servers)

        if 'state' == opt.cmd:
            print(json.dumps(cli.get_state(), indent=4, sort_keys=True))
        elif 'put' == opt.cmd:
            docs = dict(abcd=(10000000001000000000, 'Bhupendra'))
            print(json.dumps(cli.put(docs), indent=4, sort_keys=True))
