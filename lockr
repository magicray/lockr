#!/usr/bin/env python
import os
import sys
import ssl
import cmd
import time
import json
import shlex
import socket
import select
import struct
import hashlib
import sqlite3
import optparse
import traceback
from OpenSSL import crypto


def epoll_loop(port, on_recv, on_connect, clients, stats):
    key = crypto.PKey()
    key.generate_key(crypto.TYPE_RSA, 2048)
    cert = crypto.X509()
    cert.gmtime_adj_notBefore(0)
    cert.gmtime_adj_notAfter(30*24*60*60)
    cert.set_pubkey(key)
    cert.sign(key, 'sha1')

    with open('cert', 'w') as fd:
        fd.write(crypto.dump_certificate(crypto.FILETYPE_PEM, cert))
    with open('key', 'w') as fd:
        fd.write(crypto.dump_privatekey(crypto.FILETYPE_PEM, key))

    listener_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listener_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    listener_sock.bind(port)
    listener_sock.listen(5)
    listener_sock.setblocking(0)

    epoll = select.epoll()
    epoll.register(listener_sock.fileno(), select.EPOLLIN)

    stats.update(dict(in_pkt=0, in_bytes=0, out_pkt=0, out_bytes=0,
                      srv_accept=0, srv_established=0, srv_disconnect=0,
                      cli_connect=0, cli_established=0, cli_disconnect=0))
    connections = dict()
    clients = set(clients)

    while True:
        while clients:
            ip, port = clients.pop()
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
            s.setblocking(0)
            connections[s.fileno()] = dict(
                sock=s,
                handshake_done=False,
                is_server=False,
                msgs=list(),
                in_hdr_size=8,
                in_hdr_pkts=list(),
                ip_port=(ip, port))
            epoll.register(s.fileno(), select.EPOLLOUT)
            try:
                stats['cli_connect'] += 1
                s.connect((ip, port))
            except Exception as e:
                if 115 != e.errno:
                    raise

        for fileno, event in epoll.poll():
            if listener_sock.fileno() == fileno:
                s, addr = listener_sock.accept()
                s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                stats['srv_accept'] += 1
                s.setblocking(0)
                s = ssl.wrap_socket(s,
                                    keyfile='key',
                                    certfile='cert',
                                    do_handshake_on_connect=False,
                                    server_side=True)
                connections[s.fileno()] = dict(
                    sock=s,
                    is_server=True,
                    handshake_done=False,
                    msgs=list(),
                    in_hdr_size=8,
                    in_hdr_pkts=list())
                epoll.register(s.fileno(), select.EPOLLIN)
                continue
            try:
                conn = connections[fileno]

                if False == conn['handshake_done']:
                    if getattr(conn['sock'], 'do_handshake', None) is None:
                        conn['sock'] = ssl.wrap_socket(
                            conn['sock'],
                            do_handshake_on_connect=False,
                            server_side=False)
                    try:
                        conn['sock'].do_handshake()
                        conn['handshake_done'] = True
                        conn['peer'] = conn['sock'].getpeername()
                        if conn['is_server']:
                            epoll.modify(fileno, select.EPOLLIN)
                        else:
                            result = on_connect(conn['peer'])
                            for r in result:
                                conn['msgs'].append(r)
                                epoll.modify(fileno, select.EPOLLOUT)
                    except ssl.SSLError as e:
                        if ssl.SSL_ERROR_WANT_READ == e.errno:
                            epoll.modify(fileno, select.EPOLLIN)
                        elif ssl.SSL_ERROR_WANT_WRITE == e.errno:
                            epoll.modify(fileno, select.EPOLLOUT)
                        else:
                            raise
                    continue

                select_flags = select.EPOLLIN
                if event & select.EPOLLIN:
                    if 'in_size' not in conn:
                        read_bytes = conn['in_hdr_size']
                    else:
                        read_bytes = conn['in_size']

                    try:
                        buf = conn['sock'].recv(read_bytes)
                        stats['in_bytes'] += len(buf)
                    except Exception as e:
                        epoll.modify(fileno, select.EPOLLIN)
                        continue

                    if 0 == len(buf):
                        raise Exception('closed by peer')

                    result = []
                    if 'in_size' not in conn:
                        conn['in_hdr_pkts'].append(buf)
                        conn['in_hdr_size'] -= len(buf)
                        if 0 == conn['in_hdr_size']:
                            type, size = struct.unpack(
                                '!II',
                                ''.join(conn['in_hdr_pkts']))
                            conn['type'] = type
                            if 0 == size:
                                stats['in_pkt'] += 1
                                result = handler(conn['peer'], type, '')
                            else:
                                conn['in_size'] = size
                                conn['in_pkts'] = list()
                            conn['in_hdr_size'] = 8
                            conn['in_hdr_pkts'] = list()
                    else:
                        conn['in_pkts'].append(buf)
                        conn['in_size'] -= len(buf)
                        if 0 == conn['in_size']:
                            pkt = ''.join(conn['in_pkts'])
                            del(conn['in_size'])
                            del(conn['in_pkts'])
                            stats['in_pkt'] += 1
                            result = handler(conn['peer'], conn['type'], pkt)

                    if result:
                        for r in result:
                            conn['msgs'].append(r)
                            select_flags |= select.EPOLLOUT

                elif event & select.EPOLLOUT:
                    if 'out_pkt' not in conn:
                        stats['out_pkt'] += 1
                        if conn['msgs']:
                            if conn['msgs']:
                                peer, type, msg = conn['msgs'].pop(0)
                                conn['out_pkt'] = msg
                                conn['out_hdr'] = struct.pack('!II',
                                                              type,
                                                              len(msg))
                                conn['out_sent'] = 0
                                conn['out_hdr_sent'] = 0
                                select_flags |= select.EPOLLOUT
                    else:
                        select_flags |= select.EPOLLOUT
                        if 8 != conn['out_hdr_sent']:
                            if 'snd_hdr' not in conn:
                                pkt = conn['out_hdr']
                                offset = conn['out_hdr_sent']
                                conn['snd_hdr'] = pkt[offset:]

                            n = conn['sock'].send(conn['snd_hdr'])
                            if n > 0:
                                del(conn['snd_hdr'])
                                conn['out_hdr_sent'] += n
                                stats['out_bytes'] += n
                        else:
                            pkt = conn['out_pkt']
                            if len(pkt) > conn['out_sent']:
                                if 'snd_pkt' not in conn:
                                    offset = conn['out_sent']
                                    conn['snd_pkt'] = pkt[offset:]

                                n = conn['sock'].send(conn['snd_pkt'])
                                if n > 0:
                                    del(conn['snd_pkt'])
                                    conn['out_sent'] += n
                                    stats['out_bytes'] += n
                            else:
                                del(conn['out_sent'])
                                del(conn['out_hdr_sent'])
                                del(conn['out_hdr'])
                                del(conn['out_pkt'])
                                stats['out_pkt'] += 1
                else:
                    raise Exception('unhandled event({0})'.format(event))

                epoll.modify(fileno, select_flags)

            except Exception as e:
                #traceback.print_exc()
                conn = connections.pop(fileno)
                conn['sock'].close()
                epoll.unregister(fileno)
                if conn['is_server']:
                    stats['srv_disconnect'] += 1
                else:
                    stats['cli_disconnect'] += 1
                    clients.add((conn['ip_port'][0], conn['ip_port'][1]))


def log(msg):
    timestamp = time.time()
    os.write(2, '{0}.{1} : {2}\n'.format(
        time.strftime('%y%m%d.%H%M%S', time.gmtime(timestamp)),
        '%06d' % ((timestamp - int(timestamp)) * 10**6),
        msg))


class Lockr(object):
    def __init__(self, servers):
        self.servers = servers
        self.sock = None

    def connect(self):
        for ip, port in self.servers:
            sys.stdout.write('connection with {0}:{1}.....'.format(ip, port))
            try:
                t = time.time()
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock = ssl.wrap_socket(sock)
                sock.connect((ip, port))
                t = int((time.time()-t)*1000)
                sys.stdout.write('succeeded in {0} msec\n'.format(t))
                return sock
            except:
                t = int((time.time()-t)*1000)
                sys.stdout.write('failed in {0} msec\n'.format(t))
        raise Exception('could not connect to server')

    def request(self, req, buf):
        def recv(length):
            pkt = list()
            while length > 0:
                pkt.append(self.sock.recv(length))
                if 0 == len(pkt[-1]):
                    raise Exception('connection closed')
                length -= len(pkt[-1])
            return ''.join(pkt)

        while True:
            try:
                if not self.sock:
                    self.sock = self.connect()
                self.sock.sendall(struct.pack('!II', req, len(buf)))
                self.sock.sendall(buf)
                break
            except:
                time.sleep(1)
                self.sock = None

        type, size = struct.unpack('!II', recv(8))
        return recv(size)

    def get_state(self):
        return json.loads(self.request(2, ''))

    def put(self, docs):
        items = [struct.pack('!B', 1)]
        for k, v in docs.iteritems():
            ver = '0-0' if (v[0] is '-' or v[0] is None) else v[0]

            items.append(hashlib.sha256(k).digest())
            items.append(struct.pack('!Q', int(ver.split('-')[0])))
            items.append(struct.pack('!Q', int(ver.split('-')[1])))
            items.append(struct.pack('!Q', len(v[1])))
            items.append(v[1])

        return self.request(4, ''.join(items))

    def get(self, keys):
        items = [struct.pack('!B', 2)]
        hashdict = dict()
        for key in keys:
            h = hashlib.sha256(key).digest()
            items.append(h)
            hashdict[h] = key

        buf = self.request(3, ''.join(items))
        i = 0
        docs = dict()
        while i < len(buf):
            k = hashdict[buf[i:i+32]]
            f = struct.unpack('!Q', buf[i+32:i+40])[0]
            o = struct.unpack('!Q', buf[i+40:i+48])[0]
            l = struct.unpack('!Q', buf[i+48:i+56])[0]
            docs[k] = ('{0}-{1}'.format(f, o), buf[i+56:i+56+l])

            i += 56 + l

        return docs


def scan(path, from_file, from_offset, checksum, to_file, to_offset, callback):
    total_size = 0
    file_closed = False
    for filenum in range(from_file, to_file+1):
        with open(os.path.join(path, str(filenum))) as fd:
            fd.seek(0, 2)
            total_size = fd.tell()

            offset = from_offset if(filenum == from_file) else 0
            fd.seek(offset)

            try:
                while(offset < total_size):
                    b = fd.read(8)
                    assert(len(b) == 8)

                    x = fd.read(struct.unpack('!Q', b)[0])
                    y = fd.read(20)
                    assert(len(y) == 20)

                    if (0 == len(x)) and (offset != 0):
                        file_closed = True

                    chksum = hashlib.sha1(checksum)
                    chksum.update(x)
                    assert(y == chksum.digest())
                    checksum = y

                    i = 0
                    while i < len(x):
                        key = x[i:i+32]
                        length = struct.unpack('!Q', x[i+32:i+40])[0]
                        ofst = offset+8+i+40
                        i += 40 + length

                        callback(key, filenum, ofst, length)

                    offset += len(x) + 28
                    assert(offset <= total_size)

                    log('scanned file({0}) offset({1})'.format(
                        filenum, fd.tell()))
            except:
                traceback.print_exc()
                break

    return (filenum, offset, checksum, total_size, file_closed)


def stats_server(peer, buf):
    msg = json.dumps(dict(
                file=G['index'].file,
                offset=G['index'].offset,
                netstats=G['netstats']))
    return [(peer, 1, msg)]


def stats_client(peer, buf):
    G['peers'][peer] = json.loads(buf)
    return [(peer, 0, '')]


def lockr_state_handler(peer, buf):
    state = dict()
    for ip, port in G['peers']:
        state['{0}:{1}'.format(ip, port)] = G['peers'][(ip, port)]

    return [(peer, 2, json.dumps(dict(
        file=G['index'].file,
        offset=G['index'].offset,
        candidate=G['candidate'],
        netstats=G['netstats'],
        peers=state,
        timestamp=time.strftime('%y%m%d.%H%M%S', time.gmtime()))))]


def lockr_put_handler(peer, buf):
    docs = dict()
    i = 1
    while i < len(buf):
        length = struct.unpack('!Q', buf[i+48:i+56])[0]

        docs[buf[i:i+32]] = (
            struct.unpack('!Q', buf[i+32:i+40])[0],
            struct.unpack('!Q', buf[i+40:i+48])[0],
            buf[i+56:i+56+length])

        i += 56 + length

    assert(i == len(buf)), 'invalid put request'

    if G['index'].offset > opt.size:
        if G['fd']:
            G['index'].append_record(dict())
            os.close(G['fd'])
        G['index'].file += 1
        G['index'].offset = 0
        G['fd'] = None

    if not G['fd']:
        G['fd'] = os.open(
            os.path.join('data', str(G['index'].file)),
            os.O_CREAT | os.O_WRONLY | os.O_APPEND)

        if 0 == G['index'].offset:
            G['index'].append_record(dict())

    try:
        G['index'].append_record(docs)
        result = struct.pack('!B', 0)
    except:
        result = struct.pack('!B', 1)

    return [(peer, 0, result)]

def lockr_get_handler(peer, buf):
    result = list()
    i = 1
    while i < len(buf):
        key = buf[i:i+32]
        f, o, l = G['index'].get(key)
        result.append(key)
        result.append(struct.pack('!Q', f))
        result.append(struct.pack('!Q', o))
        result.append(struct.pack('!Q', l))
        if l > 0:
            with open(os.path.join('data', str(f))) as fd:
                fd.seek(o)
                result.append(fd.read(l))
        i += 32

    return [(peer, 0, ''.join(result))]


def handler(peer, type, buf):
    return [
        stats_server,
        stats_client,
        lockr_state_handler,
        lockr_get_handler,
        lockr_put_handler
    ][type](peer, buf)


def on_connect(peer):
    log('on_connect {0}'.format(peer))
    return [(peer, 0, '')]


class StatsServer():
    def on_accept(self, peer):
        return 'recv'

    def on_recv(self, buf):
        if 'stats' == buf:
            return ('send', json.dumps(dict(
                file=G['index'].file,
                offset=G['index'].offset,
                netstats=G['netstats'])))
        else:
            filenum, offset = buf.split('-')
            if os.path.isfile(os.path.join(opt.data, filenum)):
                with open(os.path.join(opt.data, filenum)) as fd:
                    fd.seek(int(offset))
                    return ('send', fd.read(10**6))
            else:
                return ('send', '')

    def on_send(self):
        return 'recv'

    def on_close(self, peer):
        pass


class StatsClient():
    def __init__(self):
        self.peer = None
        self.expected = 'stats'

    def on_connect(self, peer):
        self.peer = peer
        self.expected = 'stats'
        return ('send', 'stats')

    def on_recv(self, buf):
        if 'stats' == self.expected:
            stats = json.loads(buf)
            G['peers'][self.peer] = stats

            local = G['index'].file*2**64 + G['index'].offset
            peer = stats['file']*2**64 + stats['offset']

            if peer > local:
                self.expected = '{0}-{1}'.format(
                    G['index'].file, G['index'].total_size)
                return ('send', self.expected)

            return ('send', self.expected)
        else:
            if len(buf):
                if not G['fd']:
                    G['fd'] = os.open(
                        os.path.join('data', str(G['index'].file)),
                        os.O_CREAT | os.O_WRONLY | os.O_APPEND)

                os.write(G['fd'], buf)
                filenum, offset, chksum, total_size, file_closed = scan(
                    opt.data, G['index'].file, G['index'].offset,
                    G['index'].checksum, G['index'].file,
                    2**50, G['index'].put)

                G['index'].checksum = chksum
                if not file_closed:
                    G['index'].offset = offset
                    G['index'].total_size = total_size
                else:
                    os.close(G['fd'])
                    G['fd'] = None
                    G['index'].offset = 0
                    G['index'].total_size = 0
                    G['index'].file += 1

                self.expected = '{0}-{1}'.format(
                    G['index'].file, G['index'].total_size)
                return ('send', self.expected)
            else:
                self.expected = 'stats'
                return ('send', self.expected)

    def on_send(self):
        return 'recv'

    def on_close(self, peer):
        G['peers'][peer] = None
        return 'reconnect'


class DB():
    def __init__(self, db_file, data_dir):
        self.index = sqlite3.connect(db_file)
        self.index.execute('''create table if not exists docs
            (key blob primary key, file int, offset int, length int)''')

        self.timestamp = int(time.time())
        self.file = 0
        self.offset = 0
        self.total_size = 0
        self.checksum = ''

        result = self.index.execute('''select file, offset, length
            from docs order by file desc, offset desc limit 1''').fetchall()
        if result:
            offset = result[0][1] + result[0][2]
            with open(os.path.join('data', str(result[0][0]))) as fd:
                fd.seek(offset)
                self.file = result[0][0]
                self.offset = offset+20
                self.checksum = fd.read(20)

        files = sorted([int(f) for f in os.listdir(data_dir)])
        if files:
            if '' == self.checksum:
                with open(os.path.join(data_dir, str(min(files)))) as fd:
                    assert(0 == struct.unpack('!Q', fd.read(8))[0])
                    self.file = min(files)
                    self.offset = 28
                    self.checksum = fd.read(20)

            self.file, self.offset, self.checksum, self.total_size, _ = scan(
                data_dir, self.file, self.offset, self.checksum, max(files),
                2**50, self.put)
            assert(max(files) == self.file)
            #with open(os.path.join(data_dir, str(self.file)), 'w') as fd:
            #    fd.truncate(self.offset)
            self.index.commit()

    def commit(self):
        if int(time.time()) > self.timestamp:
            self.index.commit()
            self.timestamp = int(time.time())

    def put(self, key, filenum, offset, length):
        self.commit()
        self.index.execute(
            'insert or replace into docs values(?, ?, ?, ?)',
            (sqlite3.Binary(key), filenum, offset, length))

    def get(self, key):
        self.commit()
        result = self.index.execute(
            'select file, offset, length from docs where key=?',
            (sqlite3.Binary(key),)).fetchall()
        return result[0] if result else (0, 0, 0)

    def append_record(self, docs):
        buf_len = 0
        buf_list = list()
        for k, v in docs.iteritems():
            f, o, l = self.get(k)
            assert((v[0] == f) and (v[1] == o)), 'version mismatch'

            buf_list.append(k)
            buf_list.append(struct.pack('!Q', len(v[2])))
            buf_list.append(v[2])
            buf_len += 40 + len(v[2])

        offset = self.offset
        offset += 8
        for k, v in docs.iteritems():
            self.put(k, self.file, offset+32+8, len(v[2]))
            offset += 32 + 8 + len(v[2])

        chksum = hashlib.sha1(self.checksum)
        map(lambda b: chksum.update(b), buf_list)

        buf_list.insert(0, struct.pack('!Q', buf_len))
        buf_list.append(chksum.digest())

        os.write(G['fd'], ''.join(buf_list))

        self.offset = offset + 20
        self.checksum = chksum.digest()


class Client(cmd.Cmd):
    prompt = '>'

    def __init__(self, servers):
        cmd.Cmd.__init__(self)
        self.cli = Lockr(servers)

    def do_EOF(self, line):
        self.do_quit(line)

    def do_quit(self, line):
        exit(0)

    def do_state(self, line):
        print(json.dumps(self.cli.get_state(), indent=4, sort_keys=True))

    def do_get(self, line):
        for k, v in self.cli.get(line.split()).iteritems():
            print('{0} <{1}> {2}'.format(k, v[0], v[1]))

    def do_put(self, line):
        try:
            cmd = shlex.split(line)
            tup = zip(cmd[0::3], cmd[1::3], cmd[2::3])
            docs = dict([(t[0], (t[1], t[2])) for t in tup])
            print(struct.unpack('!B', self.cli.put(docs))[0])
        except:
            traceback.print_exc()


if '__main__' == __name__:
    parser = optparse.OptionParser()
    parser.add_option('-b', '--bind', dest='port', type='string',
                      help='server:port pair. skip to start the client')
    parser.add_option('-s', '--servers', dest='servers', type='string',
                      help='comma separated list of ip:port')
    parser.add_option('-m', '--max-file-size', dest='size', type='int',
                      help='max data file size before roll over',
                      default=134217728)
    parser.add_option('-i', '--index-file', dest='index', type='string',
                      help='index file path', default='index')
    parser.add_option('-d', '--data-dir', dest='data', type='string',
                      help='data directory path', default='data')
    opt, args = parser.parse_args()

    servers = list()
    if opt.servers:
        servers = set(map(lambda x: (socket.gethostbyname(x[0]), int(x[1])),
                          map(lambda x: x.split(':'),
                              opt.servers.split(','))))
    if not opt.port:
        Client(servers).cmdloop()

    if not os.path.isdir(opt.data):
        os.mkdir(opt.data)

    G = dict(
        netstats=dict(),
        fd=None,
        candidate=None,
        index=DB(opt.index, opt.data),
        peers=dict((ip_port, None) for ip_port in servers))

    opt.port = (
        socket.gethostbyname(opt.port.split(':')[0]),
        int(opt.port.split(':')[1]))

    epoll_loop(
        opt.port,
        handler,
        on_connect,
        [(p[0], int(p[1])) for p in G['peers']],
        G['netstats'])
    epoll_loop(
        opt.port,
        [LockrServer, StatsServer],
        [(p[0], p[1], 1, StatsClient()) for p in G['peers']],
        G['netstats'])
