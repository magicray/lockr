#!/usr/bin/env python
import os
import time
import socket
import struct
import select
import optparse


def log(msg):
    timestamp = time.time()
    os.write(2, '{0}.{1} : {2}\n'.format(
        time.strftime('%y%m%d.%H%M%S', time.gmtime(timestamp)),
        '%06d' % ((timestamp - int(timestamp)) * 10**6),
        msg))


class EPollLoop(object):
    def __init__(self, port):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.sock.bind(('0.0.0.0', port))
        self.sock.listen(5)
        self.sock.setblocking(0)

        self.epoll = select.epoll()
        self.epoll.register(self.sock.fileno(), select.EPOLLIN)

        self.connections = dict()

    def connect(self, ip, port):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.setblocking(0)
            self.connections[sock.fileno()] = dict(
                sock=sock,
                peer=(ip, port))
            self.epoll.register(sock.fileno(), select.EPOLLOUT)
            sock.connect((ip, port))
        except:
            pass

    def send(self, fileno, buf):
        conn = self.connections[fileno]

        if 'out_pkt' in conn:
            raise Exception('msg is already being sent to {0}'.format(fileno))

        conn['out_pkt'] = buf
        conn['out_sent'] = 0
        self.epoll.modify(fileno, select.EPOLLIN | select.EPOLLOUT)

    def recv(self, fileno, recv_size):
        conn = self.connections[fileno]
        conn['in_size'] = recv_size
        conn['in_pkts'] = list()

    def run(self):
        def recv(fileno, size):
            conn = self.connections[fileno]
            buf = conn['sock'].recv(size)
            if 0 == len(buf):
                raise Exception('receive failed')

            return buf

        while True:
            for fileno, event in self.epoll.poll(0.1):
                try:
                    if self.sock.fileno() == fileno:
                        sock, addr = self.sock.accept()
                        log('addr{0} connected'.format(addr))
                        sock.setblocking(0)
                        self.connections[sock.fileno()] = dict(sock=sock)
                        self.epoll.register(sock.fileno(), select.EPOLLIN)
                        self.on_contacted(sock.fileno(), sock.getpeername())
                    else:
                        if event & select.EPOLLIN:
                            conn = self.connections[fileno]
                            peer = conn['sock'].getpeername()

                            if 'in_size' in conn:
                                if conn['in_size'] > 0:
                                    pkt = recv(fileno, conn['in_size'])
                                    conn['in_pkts'].append(pkt)
                                    conn['in_size'] -= len(pkt)
                                if conn['in_size'] == 0:
                                    buf = ''.join(conn['in_pkts'])
                                    del(conn['in_pkts'])
                                    del(conn['in_size'])

                                    self.on_read(fileno, peer, buf)

                        if event & select.EPOLLOUT:
                            conn = self.connections[fileno]
                            peer = conn['sock'].getpeername()

                            if 'out_pkt' not in conn:
                                self.on_connect(fileno, peer)
                            else:
                                pkt = conn['out_pkt']
                                sock = conn['sock']

                                sent = sock.send(pkt[conn['out_sent']:])
                                if 0 == sent:
                                    raise Exception('could not send')
                                conn['out_sent'] += sent

                                if len(pkt) == conn['out_sent']:
                                    del(conn['out_sent'])
                                    del(conn['out_pkt'])
                                    self.on_write(fileno)
                                self.epoll.modify(fileno, select.EPOLLIN)

                    if event & ~(select.EPOLLIN | select.EPOLLOUT):
                        raise Exception('unhandled event({0})'.format(event))

                except Exception as e:
                    self.on_close(fileno)
                    self.epoll.unregister(fileno)
                    log('disconnected addr{0} {1}'.format(
                        self.connections[fileno]['peer'],
                        str(e)))
                    self.connections[fileno]['sock'].close()
                    del(self.connections[fileno])

            self.timer()


class StatsServer():
    def __init__(self, peer):
        self.peer = peer

    def on_accept(self):
        return ('recv', 4)

    def on_recv(self, buf):
        log('stats_server{0} {1}'.format(self.peer, buf))
        return ('send', buf)

    def on_send(self):
        return ('recv', 4)


class StatsClient():
    def __init__(self, peer):
        self.peer = peer

    def on_connect(self):
        return ('send', 'SABCD')

    def on_recv(self, buf):
        log('stats_client{0} {1}'.format(self.peer, buf))
        return ('send', 'ABCD')

    def on_send(self):
        return ('recv', 4)


class Application(EPollLoop):
    def __init__(self, port, peers):
        super(self.__class__, self).__init__(port)
        self.conns = dict()

        self.peers = dict()
        for x in peers.split(','):
            ip, addr = x.split(':')
            self.peers[(ip, int(addr))] = None

    def on_close(self, fileno):
        log('on_close {0}'.format(fileno))
        if fileno in self.conns:
            self.conns[fileno]

    def on_contacted(self, fileno, peer):
        log('on_contacted {0}'.format(fileno))
        self.conns[fileno] = dict(peer=peer, state='contacted')
        self.recv(fileno, 1)

    def on_connect(self, fileno, peer):
        self.conns[fileno] = dict(peer=peer, state='client')
        self.conns[fileno]['handler'] = StatsClient(peer)
        self.peers[peer] = fileno

        next, value = self.conns[fileno]['handler'].on_connect()
        log(str((next, value)))
        if 'recv' == next:
            self.recv(fileno, value)
        elif 'send' == next:
            self.send(fileno, value)

    def on_read(self, fileno, peer, buf):
        conn = self.conns[fileno]
        if 'contacted' == conn['state']:
            if 'S' == buf:
                conn['handler'] = StatsServer(peer)

            conn['state'] = 'server'
            next, value = conn['handler'].on_accept()
        else:
            next, value = conn['handler'].on_recv(buf)

        if 'recv' == next:
            self.recv(fileno, value)
        elif 'send' == next:
            self.send(fileno, value)

    def on_write(self, fileno):
        conn = self.conns[fileno]

        next, value = conn['handler'].on_send()

        if 'recv' == next:
            self.recv(fileno, value)

    def timer(self):
        for peer, handler in self.peers.iteritems():
            if handler is None:
                ip, port = peer
                log('connecting to {0}'.format(str((ip, port))))
                self.connect(ip, port)


def test(ip, port):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((ip, port))
    sock.send(struct.pack('!B', 83))

    while True:
        sock.send('ABCDEFGH')
        print(sock.recv(1000))

if '__main__' == __name__:
    parser = optparse.OptionParser()
    parser.add_option('--peers', dest='peers', type='string')
    parser.add_option('--port', dest='port', type='int')
    opt, args = parser.parse_args()

    if 'server' == args[0]:
        app = Application(opt.port, opt.peers)
        app.run()
    else:
        test('localhost', opt.port)
