#!/usr/bin/env python
import os
import sys
import ssl
import cmd
import time
import json
import shlex
import socket
import select
import struct
import hashlib
import sqlite3
import optparse
import traceback
from OpenSSL import crypto


def epoll_loop(port, servers, clients, stats):
    key = crypto.PKey()
    key.generate_key(crypto.TYPE_RSA, 2048)
    cert = crypto.X509()
    cert.gmtime_adj_notBefore(0)
    cert.gmtime_adj_notAfter(30*24*60*60)
    cert.set_pubkey(key)
    cert.sign(key, 'sha1')

    with open('cert', 'w') as fd:
        fd.write(crypto.dump_certificate(crypto.FILETYPE_PEM, cert))
    with open('key', 'w') as fd:
        fd.write(crypto.dump_privatekey(crypto.FILETYPE_PEM, key))

    listener_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listener_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    listener_sock.bind((port.split(':')[0], int(port.split(':')[1])))
    listener_sock.listen(5)
    listener_sock.setblocking(0)

    epoll = select.epoll()
    epoll.register(listener_sock.fileno(), select.EPOLLIN)

    stats.update(dict(in_pkt=0, in_bytes=0, out_pkt=0, out_bytes=0,
                      srv_accept=0, srv_established=0, srv_disconnect=0,
                      cli_connect=0, cli_established=0, cli_disconnect=0))
    connections = dict()

    while True:
        while clients:
            ip, port, proto, handler = clients.pop()
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
            s.setblocking(0)
            connections[s.fileno()] = dict(
                sock=s,
                handshake_done=False,
                is_server=False,
                ip_port=(ip, port),
                proto=proto,
                handler=handler)
            epoll.register(s.fileno(), select.EPOLLOUT)
            try:
                stats['cli_connect'] += 1
                s.connect((ip, port))
            except Exception as e:
                if 115 != e.errno:
                    raise

        for fileno, event in epoll.poll():
            if listener_sock.fileno() == fileno:
                s, addr = listener_sock.accept()
                s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                stats['srv_accept'] += 1
                s.setblocking(0)
                s = ssl.wrap_socket(s,
                                    keyfile='key',
                                    certfile='cert',
                                    do_handshake_on_connect=False,
                                    server_side=True)
                connections[s.fileno()] = dict(
                    sock=s,
                    is_server=True,
                    handshake_done=False,
                    peer=s.getpeername())
                epoll.register(s.fileno(), select.EPOLLIN)
                continue
            try:
                conn = connections[fileno]

                if False == conn['handshake_done']:
                    if getattr(conn['sock'], 'do_handshake', None) is None:
                        conn['sock'] = ssl.wrap_socket(
                            conn['sock'],
                            do_handshake_on_connect=False,
                            server_side=False)
                    try:
                        conn['sock'].do_handshake()
                        conn['handshake_done'] = True
                        if 'handler' in conn:
                            epoll.modify(fileno, select.EPOLLOUT)
                        else:
                            epoll.modify(fileno, select.EPOLLIN)
                    except ssl.SSLError as e:
                        if ssl.SSL_ERROR_WANT_READ == e.errno:
                            epoll.modify(fileno, select.EPOLLIN)
                        elif ssl.SSL_ERROR_WANT_WRITE == e.errno:
                            epoll.modify(fileno, select.EPOLLOUT)
                        else:
                            raise
                    continue

                if event & select.EPOLLIN:
                    result = select.EPOLLIN
                    if 'handler' not in conn:
                        read_bytes = 1
                    elif 'in_size' not in conn:
                        read_bytes = conn['in_hdr_size']
                    else:
                        read_bytes = conn['in_size']

                    try:
                        buf = conn['sock'].recv(read_bytes)
                        stats['in_bytes'] += len(buf)
                    except Exception as e:
                        epoll.modify(fileno, select.EPOLLIN)
                        continue

                    if 0 == len(buf):
                        raise Exception('closed by peer')

                    if 'handler' not in conn:
                        proto = struct.unpack('!B', buf)[0]
                        conn['handler'] = servers[proto]()
                        conn['proto'] = proto
                        conn['in_hdr_size'] = 4
                        conn['in_hdr_pkts'] = list()
                        log('accepted {0}'.format(conn['peer']))
                        stats['srv_established'] += 1
                        result = conn['handler'].on_accept(conn['peer'])
                    elif 'in_size' not in conn:
                        conn['in_hdr_pkts'].append(buf)
                        conn['in_hdr_size'] -= len(buf)
                        if 0 == conn['in_hdr_size']:
                            size = struct.unpack(
                                '!I',
                                ''.join(conn['in_hdr_pkts']))[0]
                            if 0 == size:
                                stats['in_pkt'] += 1
                                result = conn['handler'].on_recv('')
                            else:
                                conn['in_size'] = size
                                conn['in_pkts'] = list()
                            conn['in_hdr_size'] = 4
                            conn['in_hdr_pkts'] = list()
                    else:
                        conn['in_pkts'].append(buf)
                        conn['in_size'] -= len(buf)
                        if 0 == conn['in_size']:
                            pkt = ''.join(conn['in_pkts'])
                            del(conn['in_size'])
                            del(conn['in_pkts'])
                            stats['in_pkt'] += 1
                            result = conn['handler'].on_recv(pkt)

                elif event & select.EPOLLOUT:
                    result = select.EPOLLOUT
                    if 'out_pkt' not in conn:
                        if 'peer' not in conn:
                            proto = struct.pack('!B', conn['proto'])
                            if 1 == conn['sock'].send(proto):
                                conn['peer'] = conn['sock'].getpeername()
                                conn['in_hdr_size'] = 4
                                conn['in_hdr_pkts'] = list()
                                log('connected {0}'.format(conn['peer']))
                                stats['cli_established'] += 1
                                stats['out_bytes'] += 1
                                result = conn['handler'].on_connect(
                                    conn['peer'])
                            else:
                                log('unexpected code path')
                                exit(0)
                        else:
                            stats['out_pkt'] += 1
                            result = conn['handler'].on_send()
                    else:
                        if 4 != conn['out_hdr_sent']:
                            if 'snd_hdr' not in conn:
                                pkt = conn['out_hdr']
                                offset = conn['out_hdr_sent']
                                conn['snd_hdr'] = pkt[offset:]

                            n = conn['sock'].send(conn['snd_hdr'])
                            if n > 0:
                                del(conn['snd_hdr'])
                                conn['out_hdr_sent'] += n
                                stats['out_bytes'] += n
                        else:
                            pkt = conn['out_pkt']
                            if len(pkt) > conn['out_sent']:
                                if 'snd_pkt' not in conn:
                                    offset = conn['out_sent']
                                    conn['snd_pkt'] = pkt[offset:]

                                n = conn['sock'].send(conn['snd_pkt'])
                                if n > 0:
                                    del(conn['snd_pkt'])
                                    conn['out_sent'] += n
                                    stats['out_bytes'] += n
                            else:
                                del(conn['out_sent'])
                                del(conn['out_hdr_sent'])
                                del(conn['out_hdr'])
                                del(conn['out_pkt'])
                                stats['out_pkt'] += 1
                                result = conn['handler'].on_send()
                else:
                    raise Exception('unhandled event({0})'.format(event))

                epoll.modify(fileno, 0)
                if result in (select.EPOLLIN, select.EPOLLOUT):
                    epoll.modify(fileno, result)
                elif 'recv' == result:
                    epoll.modify(fileno, select.EPOLLIN)
                elif 'send' == result[0]:
                    conn['out_pkt'] = result[1]
                    conn['out_hdr'] = struct.pack('!I', len(result[1]))
                    conn['out_sent'] = 0
                    conn['out_hdr_sent'] = 0
                    epoll.modify(fileno, select.EPOLLOUT)
                else:
                    raise Exception('invalid return value')

            except Exception as e:
                #traceback.print_exc()
                conn = connections.pop(fileno)
                conn['sock'].close()
                epoll.unregister(fileno)
                if conn['is_server']:
                    stats['srv_disconnect'] += 1
                else:
                    stats['cli_disconnect'] += 1
                if 'peer' in conn:
                    log('disconnected peer{0} reason({1})'.format(
                        conn['peer'], str(e)))
                if 'handler' in conn:
                    peer = conn.get('peer') or conn['ip_port']
                    result = conn['handler'].on_close(peer)
                    if result and 'connect' == result[0]:
                        _, peer, proto, handler = result
                        clients.append((peer[0], peer[1], proto, handler))


def log(msg):
    timestamp = time.time()
    os.write(2, '{0}.{1} : {2}\n'.format(
        time.strftime('%y%m%d.%H%M%S', time.gmtime(timestamp)),
        '%06d' % ((timestamp - int(timestamp)) * 10**6),
        msg))


class Lockr(object):
    def __init__(self, servers):
        self.servers = servers
        self.sock = None

    def connect(self):
        for ip, port in self.servers:
            sys.stdout.write('connection with {0}:{1}.....'.format(ip, port))
            try:
                t = time.time()
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock = ssl.wrap_socket(sock)
                sock.connect((ip, port))
                sock.send(struct.pack('!B', 0))
                t = int((time.time()-t)*1000)
                sys.stdout.write('succeeded in {0} msec\n'.format(t))
                return sock
            except:
                t = int((time.time()-t)*1000)
                sys.stdout.write('failed in {0} msec\n'.format(t))
        raise Exception('could not connect to server')

    def request(self, buf):
        def recv(length):
            pkt = list()
            while length > 0:
                pkt.append(self.sock.recv(length))
                if 0 == len(pkt[-1]):
                    raise Exception('connection closed')
                length -= len(pkt[-1])
            return ''.join(pkt)

        while True:
            try:
                if not self.sock:
                    self.sock = self.connect()
                self.sock.sendall(struct.pack('!I', len(buf)))
                self.sock.sendall(buf)
                break
            except:
                time.sleep(1)
                self.sock = None

        return recv(struct.unpack('!I', recv(4))[0])

    def get_state(self):
        return json.loads(self.request(struct.pack('!B', 0)))

    def put(self, docs):
        items = [struct.pack('!B', 1)]
        for k, v in docs.iteritems():
            ver = '0-0' if (v[0] is '-' or v[0] is None) else v[0]

            items.append(hashlib.sha256(k).digest())
            items.append(struct.pack('!Q', int(ver.split('-')[0])))
            items.append(struct.pack('!Q', int(ver.split('-')[1])))
            items.append(struct.pack('!Q', len(v[1])))
            items.append(v[1])

        return self.request(''.join(items))

    def get(self, keys):
        items = [struct.pack('!B', 2)]
        hashdict = dict()
        for key in keys:
            h = hashlib.sha256(key).digest()
            items.append(h)
            hashdict[h] = key

        buf = self.request(''.join(items))
        i = 0
        docs = dict()
        while i < len(buf):
            k = hashdict[buf[i:i+32]]
            f = struct.unpack('!Q', buf[i+32:i+40])[0]
            o = struct.unpack('!Q', buf[i+40:i+48])[0]
            l = struct.unpack('!Q', buf[i+48:i+56])[0]
            docs[k] = ('{0}-{1}'.format(f, o), buf[i+56:i+56+l])

            i += 56 + l

        return docs


def scan(path, from_file, from_offset, checksum, to_file, to_offset, callback):
    for filenum in range(from_file, to_file+1):
        with open(os.path.join(path, str(filenum))) as fd:
            if filenum == from_file:
                fd.seek(from_offset)
                offset = from_offset
            else:
                offset = 0

            while True:
                log('scanned file({0}) offset({1})'.format(filenum, fd.tell()))
                b = fd.read(8)
                if not b:
                    break

                x = fd.read(struct.unpack('!Q', b)[0])
                y = fd.read(20)

                chksum = hashlib.sha1(checksum)
                chksum.update(x)
                assert(y == chksum.digest())
                checksum = y

                i = 0
                while i < len(x):
                    key = x[i:i+32]
                    length = struct.unpack('!Q', x[i+32:i+40])[0]
                    ofst = offset+8+i+40
                    i += 40 + length

                    callback(key, filenum, ofst, length)

                offset += len(x) + 28

    return (filenum, offset, checksum)


class StatsServer():
    def on_accept(self, peer):
        return 'recv'

    def on_recv(self, buf):
        return ('send', json.dumps(dict(
            file=G['index'].file,
            offset=G['index'].offset,
            netstats=G['netstats'])))

    def on_send(self):
        return 'recv'

    def on_close(self, peer):
        pass


class StatsClient():
    def __init__(self):
        self.peer = None

    def on_connect(self, peer):
        self.peer = peer
        return ('send', '')

    def on_recv(self, buf):
        G['peers'][self.peer] = json.loads(buf)

        G['leader'] = opt.port
        leader = dict(file=G['index'].file, offset=G['index'].offset)
        for key, value in G['peers'].iteritems():
            key = '{0}:{1}'.format(key[0], key[1])
            if value:
                first = leader['file']*2**64 + leader['offset']
                second = value['file']*2**64 + value['offset']

                if first < second:
                    G['leader'] = key
                    leader = value
                elif first == second:
                    if G['leader'] < key:
                        G['leader'] = key
                        leader = value

        return ('send', '')

    def on_send(self):
        return 'recv'

    def on_close(self, peer):
        G['peers'][peer] = None
        return ('connect', peer, 1, self)


class ReplicationServer():
    def on_accept(self, peer):
        return 'recv'

    def on_recv(self, buf):
        return ('send', json.dumps(dict(
            file=G['index'].file,
            offset=G['index'].offset,
            netstats=G['netstats'])))

    def on_send(self):
        return 'recv'

    def on_close(self, peer):
        pass


class ReplicationClient():
    def __init__(self):
        self.peer = None

    def on_connect(self, peer):
        self.peer = peer
        return ('send', '')

    def on_recv(self, buf):
        G['peers'][self.peer] = json.loads(buf)
        return ('send', '')

    def on_send(self):
        return 'recv'

    def on_close(self, peer):
        G['peers'][peer] = None
        return ('connect', peer, 1, self)


class LockrServer():
    def on_accept(self, peer):
        return 'recv'

    def on_recv(self, buf):
        handler = [
            self.handle_state_request,
            self.handle_put_request,
            self.handle_get_request]

        return ('send', handler[struct.unpack('!B', buf[0])[0]](buf))

    def on_send(self):
        return 'recv'

    def on_close(self, peer):
        pass

    def handle_state_request(self, buf):
        state = dict()
        for ip, port in G['peers']:
            state['{0}:{1}'.format(ip, port)] = G['peers'][(ip, port)]

        return json.dumps(dict(
            file=G['index'].file,
            offset=G['index'].offset,
            leader=G['leader'],
            netstats=G['netstats'],
            peers=state,
            timestamp=time.strftime('%y%m%d.%H%M%S', time.gmtime())))

    def handle_put_request(self, buf):
        docs = dict()
        i = 1
        while i < len(buf):
            length = struct.unpack('!Q', buf[i+48:i+56])[0]

            docs[buf[i:i+32]] = (
                struct.unpack('!Q', buf[i+32:i+40])[0],
                struct.unpack('!Q', buf[i+40:i+48])[0],
                buf[i+56:i+56+length])

            i += 56 + length

        assert(i == len(buf)), 'invalid put request'

        if G['index'].offset > opt.size:
            if G['fd']:
                G['index'].append_record(dict())
                os.close(G['fd'])
            G['index'].file += 1
            G['index'].offset = 0
            G['fd'] = None

        if not G['fd']:
            G['fd'] = os.open(
                os.path.join('data', str(G['index'].file)),
                os.O_CREAT | os.O_WRONLY | os.O_APPEND)

            if 0 == G['index'].offset:
                G['index'].append_record(dict())

        try:
            G['index'].append_record(docs)
            return struct.pack('!B', 0)
        except:
            return struct.pack('!B', 1)

    def handle_get_request(self, buf):
        result = list()
        i = 1
        while i < len(buf):
            key = buf[i:i+32]
            f, o, l = G['index'].get(key)
            result.append(key)
            result.append(struct.pack('!Q', f))
            result.append(struct.pack('!Q', o))
            result.append(struct.pack('!Q', l))
            if l > 0:
                with open(os.path.join('data', str(f))) as fd:
                    fd.seek(o)
                    result.append(fd.read(l))
            i += 32

        return ''.join(result)


class DB():
    def __init__(self, db_file, data_dir):
        self.index = sqlite3.connect(db_file)
        self.index.execute('''create table if not exists docs
            (key blob primary key, file int, offset int, length int)''')

        self.timestamp = int(time.time())
        self.file = 0
        self.offset = 0
        self.checksum = ''

        result = self.index.execute('''select file, offset, length
            from docs order by file desc, offset desc limit 1''').fetchall()
        if result:
            offset = result[0][1] + result[0][2]
            with open(os.path.join('data', str(result[0][0]))) as fd:
                fd.seek(offset)
                self.file = result[0][0]
                self.offset = offset+20
                self.checksum = fd.read(20)

        files = sorted([int(f) for f in os.listdir(data_dir)])
        if files:
            if '' == self.checksum:
                with open(os.path.join(data_dir, str(min(files)))) as fd:
                    assert(0 == struct.unpack('!Q', fd.read(8))[0])
                    self.file = min(files)
                    self.offset = 28
                    self.checksum = fd.read(20)

            self.file, self.offset, self.checksum = scan(
                data_dir, self.file, self.offset, self.checksum, max(files),
                2**50, self.put)
            self.index.commit()

    def commit(self):
        if int(time.time()) > self.timestamp:
            self.index.commit()
            self.timestamp = int(time.time())

    def put(self, key, filenum, offset, length):
        self.commit()
        self.index.execute(
            'insert or replace into docs values(?, ?, ?, ?)',
            (sqlite3.Binary(key), filenum, offset, length))

    def get(self, key):
        self.commit()
        result = self.index.execute(
            'select file, offset, length from docs where key=?',
            (sqlite3.Binary(key),)).fetchall()
        return result[0] if result else (0, 0, 0)

    def append_record(self, docs):
        buf_len = 0
        buf_list = list()
        for k, v in docs.iteritems():
            f, o, l = self.get(k)
            assert((v[0] == f) and (v[1] == o)), 'version mismatch'

            buf_list.append(k)
            buf_list.append(struct.pack('!Q', len(v[2])))
            buf_list.append(v[2])
            buf_len += 40 + len(v[2])

        offset = self.offset
        offset += 8
        for k, v in docs.iteritems():
            self.put(k, self.file, offset+32+8, len(v[2]))
            offset += 32 + 8 + len(v[2])

        chksum = hashlib.sha1(self.checksum)
        map(lambda b: chksum.update(b), buf_list)

        buf_list.insert(0, struct.pack('!Q', buf_len))
        buf_list.append(chksum.digest())

        os.write(G['fd'], ''.join(buf_list))

        self.offset = offset + 20
        self.checksum = chksum.digest()


class Client(cmd.Cmd):
    prompt = '>'

    def __init__(self, servers):
        cmd.Cmd.__init__(self)
        self.cli = Lockr(servers)

    def do_EOF(self, line):
        self.do_quit(line)

    def do_quit(self, line):
        exit(0)

    def do_state(self, line):
        print(json.dumps(self.cli.get_state(), indent=4, sort_keys=True))

    def do_get(self, line):
        for k, v in self.cli.get(line.split()).iteritems():
            print('{0} <{1}> {2}'.format(k, v[0], v[1]))

    def do_put(self, line):
        try:
            cmd = shlex.split(line)
            tup = zip(cmd[0::3], cmd[1::3], cmd[2::3])
            docs = dict([(t[0], (t[1], t[2])) for t in tup])
            print(struct.unpack('!B', self.cli.put(docs))[0])
        except:
            traceback.print_exc()


if '__main__' == __name__:
    parser = optparse.OptionParser()
    parser.add_option('-b', '--bind', dest='port', type='string',
                      help='server:port pair. skip to start the client')
    parser.add_option('-s', '--servers', dest='servers', type='string',
                      help='comma separated list of ip:port')
    parser.add_option('-m', '--max-file-size', dest='size', type='int',
                      help='max data file size before roll over',
                      default=134217728)
    parser.add_option('-i', '--index-file', dest='index', type='string',
                      help='index file path', default='index')
    parser.add_option('-d', '--data-dir', dest='data', type='string',
                      help='data directory path', default='data')
    parser.add_option('-l', '--log-file', dest='log', type='string',
                      help='log file path')
    opt, args = parser.parse_args()

    servers = list()
    if opt.servers:
        servers = set(map(lambda x: (socket.gethostbyname(x[0]), int(x[1])),
                          map(lambda x: x.split(':'),
                              opt.servers.split(','))))
    if not opt.port:
        Client(servers).cmdloop()

    if opt.log:
        os.dup2(os.open(opt.log, os.O_CREAT | os.O_WRONLY | os.O_APPEND), 2)

    if not os.path.isdir(opt.data):
        os.mkdir(opt.data)

    G = dict(
        netstats=dict(),
        fd=None,
        leader=None,
        index=DB(opt.index, opt.data),
        peers=dict((ip_port, None) for ip_port in servers))

    epoll_loop(
        opt.port,
        [LockrServer, StatsServer, ReplicationServer],
        [(p[0], p[1], 1, StatsClient()) for p in G['peers']],
        G['netstats'])
