#!/usr/bin/env python
import os
import ssl
import time
import json
import socket
import pickle
import struct
import hashlib
import optparse


def epoll_loop(port, servers, clients, stats):
    import select
    from OpenSSL import crypto

    key = crypto.PKey()
    key.generate_key(crypto.TYPE_RSA, 2048)
    cert = crypto.X509()
    cert.gmtime_adj_notBefore(0)
    cert.gmtime_adj_notAfter(30*24*60*60)
    cert.set_pubkey(key)
    cert.sign(key, 'sha1')

    with open('cert', 'w') as fd:
        fd.write(crypto.dump_certificate(crypto.FILETYPE_PEM, cert))
    with open('key', 'w') as fd:
        fd.write(crypto.dump_privatekey(crypto.FILETYPE_PEM, key))

    listener_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listener_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    listener_sock.bind(('0.0.0.0', port))
    listener_sock.listen(5)
    listener_sock.setblocking(0)

    epoll = select.epoll()
    epoll.register(listener_sock.fileno(), select.EPOLLIN)

    stats.update(dict(in_pkt=0, in_bytes=0, out_pkt=0, out_bytes=0,
                      srv_accept=0, srv_established=0, srv_disconnect=0,
                      cli_connect=0, cli_established=0, cli_disconnect=0))
    connections = dict()

    while True:
        while clients:
            handler = clients.pop()
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
            s.setblocking(0)
            connections[s.fileno()] = dict(
                sock=s,
                handshake_done=False,
                is_server=False,
                handler=handler)
            epoll.register(s.fileno(), select.EPOLLOUT)
            try:
                stats['cli_connect'] += 1
                s.connect((handler.conn['ip'], handler.conn['port']))
            except Exception as e:
                if 115 != e.errno:
                    raise

        for fileno, event in epoll.poll():
            if listener_sock.fileno() == fileno:
                s, addr = listener_sock.accept()
                s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                stats['srv_accept'] += 1
                s.setblocking(0)
                s = ssl.wrap_socket(s,
                                    keyfile='key',
                                    certfile='cert',
                                    do_handshake_on_connect=False,
                                    server_side=True)
                connections[s.fileno()] = dict(
                    sock=s,
                    is_server=True,
                    handshake_done=False,
                    peer=s.getpeername())
                epoll.register(s.fileno(), select.EPOLLIN)
                continue
            try:
                conn = connections[fileno]

                if False == conn['handshake_done']:
                    if getattr(conn['sock'], 'do_handshake', None) is None:
                        conn['sock'] = ssl.wrap_socket(
                            conn['sock'],
                            do_handshake_on_connect=False,
                            server_side=False)
                    try:
                        conn['sock'].do_handshake()
                        conn['handshake_done'] = True
                        if 'handler' in conn:
                            epoll.modify(fileno, select.EPOLLOUT)
                        else:
                            epoll.modify(fileno, select.EPOLLIN)
                    except ssl.SSLError as e:
                        if ssl.SSL_ERROR_WANT_READ == e.errno:
                            epoll.modify(fileno, select.EPOLLIN)
                        elif ssl.SSL_ERROR_WANT_WRITE == e.errno:
                            epoll.modify(fileno, select.EPOLLOUT)
                        else:
                            raise
                    continue

                if event & select.EPOLLIN:
                    result = select.EPOLLIN
                    if 'handler' not in conn:
                        read_bytes = 1
                    elif 'in_size' not in conn:
                        read_bytes = conn['in_hdr_size']
                    else:
                        read_bytes = conn['in_size']

                    try:
                        buf = conn['sock'].recv(read_bytes)
                        stats['in_bytes'] += len(buf)
                    except Exception as e:
                        epoll.modify(fileno, select.EPOLLIN)
                        continue

                    if 0 == len(buf):
                        raise Exception('recv returned zero bytes')

                    if 'handler' not in conn:
                        proto = struct.unpack('!B', buf)[0]
                        conn['handler'] = servers[proto]()
                        conn['in_hdr_size'] = 4
                        conn['in_hdr_pkts'] = list()
                        log('accepted {0}'.format(conn['peer']))
                        stats['srv_established'] += 1
                        result = conn['handler'].on_accept(conn['peer'])
                    elif 'in_size' not in conn:
                        conn['in_hdr_pkts'].append(buf)
                        conn['in_hdr_size'] -= len(buf)
                        if 0 == conn['in_hdr_size']:
                            size = struct.unpack(
                                '!I',
                                ''.join(conn['in_hdr_pkts']))[0]
                            if 0 == size:
                                stats['in_pkt'] += 1
                                result = conn['handler'].on_recv('')
                            else:
                                conn['in_size'] = size
                                conn['in_pkts'] = list()
                            conn['in_hdr_size'] = 4
                            conn['in_hdr_pkts'] = list()
                    else:
                        conn['in_pkts'].append(buf)
                        conn['in_size'] -= len(buf)
                        if 0 == conn['in_size']:
                            pkt = ''.join(conn['in_pkts'])
                            del(conn['in_size'])
                            del(conn['in_pkts'])
                            stats['in_pkt'] += 1
                            result = conn['handler'].on_recv(pkt)

                elif event & select.EPOLLOUT:
                    result = select.EPOLLOUT
                    if 'out_pkt' not in conn:
                        if 'peer' not in conn:
                            proto = struct.pack(
                                '!B',
                                conn['handler'].conn['proto'])
                            if 1 == conn['sock'].send(proto):
                                conn['peer'] = conn['sock'].getpeername()
                                conn['in_hdr_size'] = 4
                                conn['in_hdr_pkts'] = list()
                                log('connected {0}'.format(conn['peer']))
                                stats['cli_established'] += 1
                                stats['out_bytes'] += 1
                                result = conn['handler'].on_connect()
                            else:
                                log('unexpected code path')
                                exit(0)
                        else:
                            stats['out_pkt'] += 1
                            result = conn['handler'].on_send()
                    else:
                        if 4 != conn['out_hdr_sent']:
                            if 'snd_hdr' not in conn:
                                pkt = conn['out_hdr']
                                offset = conn['out_hdr_sent']
                                conn['snd_hdr'] = pkt[offset:]

                            n = conn['sock'].send(conn['snd_hdr'])
                            if n > 0:
                                del(conn['snd_hdr'])
                                conn['out_hdr_sent'] += n
                                stats['out_bytes'] += n
                        else:
                            pkt = conn['out_pkt']
                            if len(pkt) > conn['out_sent']:
                                if 'snd_pkt' not in conn:
                                    offset = conn['out_sent']
                                    conn['snd_pkt'] = pkt[offset:]

                                n = conn['sock'].send(conn['snd_pkt'])
                                if n > 0:
                                    del(conn['snd_pkt'])
                                    conn['out_sent'] += n
                                    stats['out_bytes'] += n
                            else:
                                del(conn['out_sent'])
                                del(conn['out_hdr_sent'])
                                del(conn['out_hdr'])
                                del(conn['out_pkt'])
                                stats['out_pkt'] += 1
                                result = conn['handler'].on_send()
                else:
                    raise Exception('unhandled event({0})'.format(event))

                if result in (select.EPOLLIN, select.EPOLLOUT):
                        epoll.modify(fileno, result)
                elif result is not False:
                    if result is True:
                        epoll.modify(fileno, select.EPOLLIN)
                    else:
                        conn['out_pkt'] = result
                        conn['out_hdr'] = struct.pack('!I', len(result))
                        conn['out_sent'] = 0
                        conn['out_hdr_sent'] = 0
                        epoll.modify(fileno, select.EPOLLOUT)

            except Exception as e:
                conn = connections[fileno]
                del(connections[fileno])
                epoll.unregister(fileno)
                conn['sock'].close()
                if conn['is_server']:
                    stats['srv_disconnect'] += 1
                else:
                    stats['cli_disconnect'] += 1
                if 'peer' in conn:
                    log('disconnected peer{0} reason({1})'.format(
                        conn['peer'], str(e)))
                if 'handler' in conn:
                    if conn['handler'].on_close() is True:
                        clients.append(conn['handler'])


def log(msg):
    timestamp = time.time()
    os.write(2, '{0}.{1} : {2}\n'.format(
        time.strftime('%y%m%d.%H%M%S', time.gmtime(timestamp)),
        '%06d' % ((timestamp - int(timestamp)) * 10**6),
        msg))


class StatsServer():
    def on_accept(self, peer):
        return True

    def on_recv(self, buf):
        return json.dumps(G['local'])

    def on_send(self):
        return True

    def on_close(self):
        pass


class StatsClient():
    def __init__(self, conn):
        self.conn = conn
        self.key = (conn['ip'], conn['port'])

    def on_connect(self):
        return ''

    def on_recv(self, buf):
        G['peers'][self.key] = json.loads(buf)
        return ''

    def on_send(self):
        return True

    def on_close(self):
        G['peers'][self.key] = None
        return True


class LockrServer():
    def on_accept(self, peer):
        return True

    def handle_put_request(self, buf):
        docs = dict()
        i = 1
        while i < len(buf):
            length = struct.unpack('!Q', buf[i+48:i+56])[0]

            docs[buf[i:i+32]] = (
                struct.unpack('!Q', buf[i+32:i+40])[0],
                struct.unpack('!Q', buf[i+40:i+48])[0],
                buf[i+56:i+56+length])

            i += 56 + length

        assert(i == len(buf)), 'invalid put request'

        result = append_record(docs)
        if not result:
            return json.dumps('conflict')

        return json.dumps('ok')

    def handle_status_request(self, buf):
        state = dict()
        for ip, port in G['peers']:
            state['{0}:{1}'.format(ip, port)] = G['peers'][(ip, port)]

        return json.dumps(dict(
            local=G['local'],
            peers=state,
            timestamp=time.strftime('%y%m%d.%H%M%S', time.gmtime())))

    def on_recv(self, buf):
        handler = {
            0: self.handle_status_request,
            1: self.handle_put_request}

        return handler[struct.unpack('!B', buf[0])[0]](buf)

    def on_send(self):
        return True

    def on_close(self):
        pass


class Lockr(object):
    def __init__(self, servers):
        self.servers = servers
        self.sock = self.connect()

    def connect(self):
        for ip, port in self.servers:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock = ssl.wrap_socket(sock)
                sock.connect((ip, port))
                sock.send(struct.pack('!B', 200))
                return sock
            except:
                pass
        raise Exception('could not connect to server')

    def request(self, buf):
        def recv(length):
            pkt = list()
            while length > 0:
                pkt.append(self.sock.recv(length))
                if 0 == len(pkt[-1]):
                    raise Exception('connection closed')
                length -= len(pkt[-1])
            return ''.join(pkt)

        self.sock.sendall(struct.pack('!I', len(buf)))
        self.sock.sendall(buf)

        return recv(struct.unpack('!I', recv(4))[0])

    def get_state(self):
        return json.loads(self.request(struct.pack('!B', 0)))

    def put(self, docs):
        items = [struct.pack('!B', 1)]
        for k, v in docs.iteritems():
            ver = '0-0' if v[0] is None else v[0]

            items.append(hashlib.sha256(k).digest())
            items.append(struct.pack('!Q', int(ver.split('-')[0])))
            items.append(struct.pack('!Q', int(ver.split('-')[1])))
            items.append(struct.pack('!Q', len(v[1])))
            items.append(v[1])

        return self.request(''.join(items))


def update_index(g):
    files = sorted([int(f) for f in os.listdir('data')])
    if not files:
        g['index'] = dict(
            file=0,
            offset=0,
            chksum=hashlib.sha1('').digest(),
            docs=dict())
        return

    if not g['index']['chksum']:
        g['index']['file'] = min(files)
        g['index']['offset'] = 28
        with open(os.path.join('data', str(min(files)))) as fd:
            assert(0 == struct.unpack('!Q', fd.read(8))[0])
            g['index']['chksum'] = fd.read(20)

    chksum = hashlib.sha1(g['index']['chksum'])
    for filenum in range(min(files), max(files)+1):
        with open(os.path.join('data', str(filenum))) as fd:
            if filenum == g['index']['file']:
                fd.seek(g['index']['offset'])

            while True:
                print(fd.tell())
                b = fd.read(8)
                if not b:
                    break
               
                x = fd.read(struct.unpack('!Q', b)[0])
                y = fd.read(20)

                chksum.update(x)
                assert(y == chksum.digest())
                chksum.update(y)

                i = 0
                while i < len(x):
                    size = struct.unpack('!Q', x[i+32:i+40])[0]
                    g['index']['docs'][x[i:i+32]] = (
                        filenum,
                        g['index']['offset']+8+i+40,
                        size)
                    i += 40 + size

                g['index']['file'] = filenum
                g['index']['offset'] += len(x) + 28
                g['index']['chksum'] = y

    with open('index.pickle', 'w') as fd:
        pickle.dump(G['index'], fd)


def append_record(docs):
    buf_len = 0
    buf_list = list()
    for k, v in docs.iteritems():
        f, o, l = G['index']['docs'].get(k, (0, 0, 0))
        assert((v[0] == f) and (v[1] == o)), 'version mismatch'

        buf_list.append(k)
        buf_list.append(struct.pack('!Q', len(v[2])))
        buf_list.append(v[2])
        buf_len += 40 + len(v[2])

    offset = G['index']['offset'] + 8
    for k, v in docs.iteritems():
        G['index']['docs'][k] = (G['index']['file'], offset+32+8, len(v[2]))
        offset += 32 + 8 + len(v[2])

    chksum = hashlib.sha1(G['index']['chksum'])
    map(lambda b: chksum.update(b), buf_list)

    buf_list.insert(0, struct.pack('!Q', buf_len))
    buf_list.append(chksum.digest())

    if 'fd' not in G:
        G['index']['file'] += 1
        G['index']['offset'] = 0

        G['fd'] = os.open(
            os.path.join('data', str(G['index']['file'])),
            os.O_CREAT | os.O_WRONLY | os.O_APPEND)

        os.write(G['fd'], struct.pack('!Q', 0) + G['index']['chksum'])

    os.write(G['fd'], ''.join(buf_list))

    G['index']['offset'] += buf_len + 28
    G['index']['chksum'] = chksum.digest()

    return G['index']['file'], G['index']['offset']


def lockr_server(servers, g):
    os.dup2(os.open('log.{0}'.format(time.strftime('%y%m%d', time.gmtime())),
                    os.O_CREAT | os.O_WRONLY | os.O_APPEND), 2)

    if os.path.isfile('index.json'):
        with open('index.json') as fd:
            g['index'] = json.load(fd)
    else:
        g['index'] = dict(file=0, offset=0, chksum='', docs=dict())
        if not os.path.isdir('data'):
            os.mkdir('data')

    update_index(g)

    G['local'] = dict(
        file_a=0,
        file_y=0,
        size_y=0,
        file_z=0,
        size_z=0,
        committed=0,
        peer_count=0,
        stats=dict())

    G['peers'] = dict((ip_port, None) for ip_port in servers)
    epoll_loop(
        opt.port,
        {100: StatsServer, 200: LockrServer},
        [StatsClient(dict(ip=p[0], port=p[1], proto=100)) for p in G['peers']],
        G['local']['stats'])


if '__main__' == __name__:
    parser = optparse.OptionParser()
    parser.add_option('--port', dest='port', type='int')
    parser.add_option('--cmd', dest='cmd', type='string')
    parser.add_option('--servers', dest='servers', type='string')
    opt, args = parser.parse_args()

    servers = list()
    if opt.servers:
        servers = set(map(lambda x: (socket.gethostbyname(x[0]), int(x[1])),
                          map(lambda x: x.split(':'),
                              opt.servers.split(','))))
    if opt.port:
        G = dict()
        lockr_server(servers, G)
    else:
        cli = Lockr(servers)

        if 'state' == opt.cmd:
            print(json.dumps(cli.get_state(), indent=4, sort_keys=True))
        elif 'put' == opt.cmd:
            docs = dict(abcd=(None, 'S'))
            print(json.dumps(cli.put(docs), indent=4, sort_keys=True))
