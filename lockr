#!/usr/bin/env python
import os
import ssl
import time
import json
import socket
import pickle
import struct
import hashlib
import optparse


def epoll_loop(port, servers, clients, stats):
    import select
    from OpenSSL import crypto

    key = crypto.PKey()
    key.generate_key(crypto.TYPE_RSA, 2048)
    cert = crypto.X509()
    cert.gmtime_adj_notBefore(0)
    cert.gmtime_adj_notAfter(30*24*60*60)
    cert.set_pubkey(key)
    cert.sign(key, 'sha1')

    with open('cert', 'w') as fd:
        fd.write(crypto.dump_certificate(crypto.FILETYPE_PEM, cert))
    with open('key', 'w') as fd:
        fd.write(crypto.dump_privatekey(crypto.FILETYPE_PEM, key))

    listener_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listener_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    listener_sock.bind(('0.0.0.0', port))
    listener_sock.listen(5)
    listener_sock.setblocking(0)

    epoll = select.epoll()
    epoll.register(listener_sock.fileno(), select.EPOLLIN)

    stats.update(dict(in_pkt=0, in_bytes=0, out_pkt=0, out_bytes=0,
                      srv_accept=0, srv_established=0, srv_disconnect=0,
                      cli_connect=0, cli_established=0, cli_disconnect=0))
    connections = dict()

    while True:
        while clients:
            ip, port, proto, handler = clients.pop()
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
            s.setblocking(0)
            connections[s.fileno()] = dict(
                sock=s,
                handshake_done=False,
                is_server=False,
                ip_port=(ip, port),
                proto=proto,
                handler=handler)
            epoll.register(s.fileno(), select.EPOLLOUT)
            try:
                stats['cli_connect'] += 1
                s.connect((ip, port))
            except Exception as e:
                if 115 != e.errno:
                    raise

        for fileno, event in epoll.poll():
            if listener_sock.fileno() == fileno:
                s, addr = listener_sock.accept()
                s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                stats['srv_accept'] += 1
                s.setblocking(0)
                s = ssl.wrap_socket(s,
                                    keyfile='key',
                                    certfile='cert',
                                    do_handshake_on_connect=False,
                                    server_side=True)
                connections[s.fileno()] = dict(
                    sock=s,
                    is_server=True,
                    handshake_done=False,
                    peer=s.getpeername())
                epoll.register(s.fileno(), select.EPOLLIN)
                continue
            try:
                conn = connections[fileno]

                if False == conn['handshake_done']:
                    if getattr(conn['sock'], 'do_handshake', None) is None:
                        conn['sock'] = ssl.wrap_socket(
                            conn['sock'],
                            do_handshake_on_connect=False,
                            server_side=False)
                    try:
                        conn['sock'].do_handshake()
                        conn['handshake_done'] = True
                        if 'handler' in conn:
                            epoll.modify(fileno, select.EPOLLOUT)
                        else:
                            epoll.modify(fileno, select.EPOLLIN)
                    except ssl.SSLError as e:
                        if ssl.SSL_ERROR_WANT_READ == e.errno:
                            epoll.modify(fileno, select.EPOLLIN)
                        elif ssl.SSL_ERROR_WANT_WRITE == e.errno:
                            epoll.modify(fileno, select.EPOLLOUT)
                        else:
                            raise
                    continue

                if event & select.EPOLLIN:
                    result = select.EPOLLIN
                    if 'handler' not in conn:
                        read_bytes = 1
                    elif 'in_size' not in conn:
                        read_bytes = conn['in_hdr_size']
                    else:
                        read_bytes = conn['in_size']

                    try:
                        buf = conn['sock'].recv(read_bytes)
                        stats['in_bytes'] += len(buf)
                    except Exception as e:
                        epoll.modify(fileno, select.EPOLLIN)
                        continue

                    if 0 == len(buf):
                        raise Exception('closed by peer')

                    if 'handler' not in conn:
                        proto = struct.unpack('!B', buf)[0]
                        conn['handler'] = servers[proto]()
                        conn['proto'] = proto
                        conn['in_hdr_size'] = 4
                        conn['in_hdr_pkts'] = list()
                        log('accepted {0}'.format(conn['peer']))
                        stats['srv_established'] += 1
                        result = conn['handler'].on_accept(conn['peer'])
                    elif 'in_size' not in conn:
                        conn['in_hdr_pkts'].append(buf)
                        conn['in_hdr_size'] -= len(buf)
                        if 0 == conn['in_hdr_size']:
                            size = struct.unpack(
                                '!I',
                                ''.join(conn['in_hdr_pkts']))[0]
                            if 0 == size:
                                stats['in_pkt'] += 1
                                result = conn['handler'].on_recv('')
                            else:
                                conn['in_size'] = size
                                conn['in_pkts'] = list()
                            conn['in_hdr_size'] = 4
                            conn['in_hdr_pkts'] = list()
                    else:
                        conn['in_pkts'].append(buf)
                        conn['in_size'] -= len(buf)
                        if 0 == conn['in_size']:
                            pkt = ''.join(conn['in_pkts'])
                            del(conn['in_size'])
                            del(conn['in_pkts'])
                            stats['in_pkt'] += 1
                            result = conn['handler'].on_recv(pkt)

                elif event & select.EPOLLOUT:
                    result = select.EPOLLOUT
                    if 'out_pkt' not in conn:
                        if 'peer' not in conn:
                            proto = struct.pack('!B', conn['proto'])
                            if 1 == conn['sock'].send(proto):
                                conn['peer'] = conn['sock'].getpeername()
                                conn['in_hdr_size'] = 4
                                conn['in_hdr_pkts'] = list()
                                log('connected {0}'.format(conn['peer']))
                                stats['cli_established'] += 1
                                stats['out_bytes'] += 1
                                result = conn['handler'].on_connect(
                                    conn['peer'])
                            else:
                                log('unexpected code path')
                                exit(0)
                        else:
                            stats['out_pkt'] += 1
                            result = conn['handler'].on_send()
                    else:
                        if 4 != conn['out_hdr_sent']:
                            if 'snd_hdr' not in conn:
                                pkt = conn['out_hdr']
                                offset = conn['out_hdr_sent']
                                conn['snd_hdr'] = pkt[offset:]

                            n = conn['sock'].send(conn['snd_hdr'])
                            if n > 0:
                                del(conn['snd_hdr'])
                                conn['out_hdr_sent'] += n
                                stats['out_bytes'] += n
                        else:
                            pkt = conn['out_pkt']
                            if len(pkt) > conn['out_sent']:
                                if 'snd_pkt' not in conn:
                                    offset = conn['out_sent']
                                    conn['snd_pkt'] = pkt[offset:]

                                n = conn['sock'].send(conn['snd_pkt'])
                                if n > 0:
                                    del(conn['snd_pkt'])
                                    conn['out_sent'] += n
                                    stats['out_bytes'] += n
                            else:
                                del(conn['out_sent'])
                                del(conn['out_hdr_sent'])
                                del(conn['out_hdr'])
                                del(conn['out_pkt'])
                                stats['out_pkt'] += 1
                                result = conn['handler'].on_send()
                else:
                    raise Exception('unhandled event({0})'.format(event))

                epoll.modify(fileno, 0)
                if result in (select.EPOLLIN, select.EPOLLOUT):
                    epoll.modify(fileno, result)
                elif 'recv' == result:
                    epoll.modify(fileno, select.EPOLLIN)
                elif 'send' == result[0]:
                    conn['out_pkt'] = result[1]
                    conn['out_hdr'] = struct.pack('!I', len(result[1]))
                    conn['out_sent'] = 0
                    conn['out_hdr_sent'] = 0
                    epoll.modify(fileno, select.EPOLLOUT)
                else:
                    raise Exception('invalid return value')

            except Exception as e:
                conn = connections.pop(fileno)
                conn['sock'].close()
                epoll.unregister(fileno)
                if conn['is_server']:
                    stats['srv_disconnect'] += 1
                else:
                    stats['cli_disconnect'] += 1
                if 'peer' in conn:
                    log('disconnected peer{0} reason({1})'.format(
                        conn['peer'], str(e)))
                if 'handler' in conn:
                    peer = conn.get('peer') or conn['ip_port']
                    result = conn['handler'].on_close(peer)
                    if result and 'connect' == result[0]:
                        _, peer, proto, handler = result
                        clients.append((peer[0], peer[1], proto, handler))


def log(msg):
    timestamp = time.time()
    os.write(2, '{0}.{1} : {2}\n'.format(
        time.strftime('%y%m%d.%H%M%S', time.gmtime(timestamp)),
        '%06d' % ((timestamp - int(timestamp)) * 10**6),
        msg))


class StatsServer():
    def on_accept(self, peer):
        return 'recv'

    def on_recv(self, buf):
        return ('send', json.dumps(dict(
            file=G['index']['file'],
            offset=G['index']['offset'],
            netstats=G['netstats'])))

    def on_send(self):
        return 'recv'

    def on_close(self, peer):
        pass


class StatsClient():
    def __init__(self):
        self.peer = None

    def on_connect(self, peer):
        self.peer = peer
        return ('send', '')

    def on_recv(self, buf):
        G['peers'][self.peer] = json.loads(buf)
        return ('send', '')

    def on_send(self):
        return 'recv'

    def on_close(self, peer):
        G['peers'][peer] = None
        return ('connect', peer, 0, self)


class LockrServer():
    def on_accept(self, peer):
        return 'recv'

    def on_recv(self, buf):
        handler = [
            self.handle_state_request,
            self.handle_put_request,
            self.handle_get_request]

        return ('send', handler[struct.unpack('!B', buf[0])[0]](buf))

    def on_send(self):
        return 'recv'

    def on_close(self, peer):
        pass

    def handle_state_request(self, buf):
        state = dict()
        for ip, port in G['peers']:
            state['{0}:{1}'.format(ip, port)] = G['peers'][(ip, port)]

        return json.dumps(dict(
            file=G['index']['file'],
            offset=G['index']['offset'],
            netstats=G['netstats'],
            peers=state,
            timestamp=time.strftime('%y%m%d.%H%M%S', time.gmtime())))

    def handle_put_request(self, buf):
        docs = dict()
        i = 1
        while i < len(buf):
            length = struct.unpack('!Q', buf[i+48:i+56])[0]

            docs[buf[i:i+32]] = (
                struct.unpack('!Q', buf[i+32:i+40])[0],
                struct.unpack('!Q', buf[i+40:i+48])[0],
                buf[i+56:i+56+length])

            i += 56 + length

        assert(i == len(buf)), 'invalid put request'

        if G['index']['offset'] > opt.size:
            if G['fd']:
                os.close(G['fd'])
            G['index']['file'] += 1
            G['index']['offset'] = 0
            G['fd'] = None

        if not G['fd']:
            G['fd'] = os.open(
                os.path.join('data', str(G['index']['file'])),
                os.O_CREAT | os.O_WRONLY | os.O_APPEND)

            if 0 == G['index']['offset']:
                append_record(dict())

        try:
            append_record(docs)
            return struct.pack('!B', 0)
        except Exception as e:
            return struct.pack('!B', 1)

    def handle_get_request(self, buf):
        result = list()
        i = 1
        while i < len(buf):
            key = buf[i:i+32]
            f, o, l = G['index']['docs'].get(key, (0, 0, 0))
            result.append(key)
            result.append(struct.pack('!Q', f))
            result.append(struct.pack('!Q', o))
            result.append(struct.pack('!Q', l))
            if l > 0:
                with open(os.path.join('data', str(f))) as fd:
                    fd.seek(o)
                    result.append(fd.read(l))
            i += 32

        return ''.join(result)


class Lockr(object):
    def __init__(self, servers):
        self.servers = servers
        self.sock = self.connect()

    def connect(self):
        for ip, port in self.servers:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock = ssl.wrap_socket(sock)
                sock.connect((ip, port))
                sock.send(struct.pack('!B', 1))
                return sock
            except:
                pass
        raise Exception('could not connect to server')

    def request(self, buf):
        def recv(length):
            pkt = list()
            while length > 0:
                pkt.append(self.sock.recv(length))
                if 0 == len(pkt[-1]):
                    raise Exception('connection closed')
                length -= len(pkt[-1])
            return ''.join(pkt)

        self.sock.sendall(struct.pack('!I', len(buf)))
        self.sock.sendall(buf)

        return recv(struct.unpack('!I', recv(4))[0])

    def get_state(self):
        return json.loads(self.request(struct.pack('!B', 0)))

    def put(self, docs):
        items = [struct.pack('!B', 1)]
        for k, v in docs.iteritems():
            ver = '0-0' if v[0] is None else v[0]

            items.append(hashlib.sha256(k).digest())
            items.append(struct.pack('!Q', int(ver.split('-')[0])))
            items.append(struct.pack('!Q', int(ver.split('-')[1])))
            items.append(struct.pack('!Q', len(v[1])))
            items.append(v[1])

        return self.request(''.join(items))

    def get(self, keys):
        items = [struct.pack('!B', 2)]
        hashdict = dict()
        for key in keys:
            h = hashlib.sha256(key).digest()
            items.append(h)
            hashdict[h] = key

        buf = self.request(''.join(items))
        i = 0
        docs = dict()
        while i < len(buf):
            k = hashdict[buf[i:i+32]]
            f = struct.unpack('!Q', buf[i+32:i+40])[0]
            o = struct.unpack('!Q', buf[i+40:i+48])[0]
            l = struct.unpack('!Q', buf[i+48:i+56])[0]
            docs[k] = ('{0}-{1}'.format(f, o), buf[i+56:i+56+l])

            i += 56 + l

        return docs


def update_index(g):
    g['index'] = dict(
        file=0,
        offset=0,
        chksum=hashlib.sha1('').digest(),
        docs=dict())

    files = sorted([int(f) for f in os.listdir('data')])
    if not files:
        return

    if os.path.isfile('index.pickle'):
        with open('index.pickle') as fd:
            g['index'] = pickle.load(fd)
    else:
        g['index']['file'] = min(files)
        g['index']['offset'] = 28
        with open(os.path.join('data', str(min(files)))) as fd:
            assert(0 == struct.unpack('!Q', fd.read(8))[0])
            g['index']['chksum'] = fd.read(20)

    for filenum in range(g['index']['file'], max(files)+1):
        with open(os.path.join('data', str(filenum))) as fd:
            if filenum == g['index']['file']:
                fd.seek(g['index']['offset'])
            else:
                g['index']['offset'] = 0

            while True:
                log('scanned file({0}) offset({1})'.format(filenum, fd.tell()))
                b = fd.read(8)
                if not b:
                    break
               
                x = fd.read(struct.unpack('!Q', b)[0])
                y = fd.read(20)

                chksum = hashlib.sha1(g['index']['chksum'])
                chksum.update(x)
                assert(y == chksum.digest())
                g['index']['chksum'] = y

                i = 0
                while i < len(x):
                    size = struct.unpack('!Q', x[i+32:i+40])[0]
                    g['index']['docs'][x[i:i+32]] = (
                        filenum,
                        g['index']['offset']+8+i+40,
                        size)
                    i += 40 + size

                g['index']['file'] = filenum
                g['index']['offset'] += len(x) + 28

    with open('index.pickle', 'w') as fd:
        pickle.dump(G['index'], fd)
        log('new index.pickle file created')


def append_record(docs):
    buf_len = 0
    buf_list = list()
    for k, v in docs.iteritems():
        f, o, l = G['index']['docs'].get(k, (0, 0, 0))
        assert((v[0] == f) and (v[1] == o)), 'version mismatch'

        buf_list.append(k)
        buf_list.append(struct.pack('!Q', len(v[2])))
        buf_list.append(v[2])
        buf_len += 40 + len(v[2])

    offset = G['index']['offset'] + 8
    for k, v in docs.iteritems():
        G['index']['docs'][k] = (G['index']['file'], offset+32+8, len(v[2]))
        offset += 32 + 8 + len(v[2])

    chksum = hashlib.sha1(G['index']['chksum'])
    map(lambda b: chksum.update(b), buf_list)

    buf_list.insert(0, struct.pack('!Q', buf_len))
    buf_list.append(chksum.digest())

    os.write(G['fd'], ''.join(buf_list))

    G['index']['offset'] += buf_len + 28
    G['index']['chksum'] = chksum.digest()

    return G['index']['file'], G['index']['offset']


def lockr_server(servers, g):
    os.dup2(os.open('log.{0}'.format(time.strftime('%y%m%d', time.gmtime())),
                    os.O_CREAT | os.O_WRONLY | os.O_APPEND), 2)

    if not os.path.isdir('data'):
        os.mkdir('data')

    update_index(g)

    G['peers'] = dict((ip_port, None) for ip_port in servers)

    epoll_loop(opt.port,
               [StatsServer, LockrServer],
               [(p[0], p[1], 0, StatsClient()) for p in G['peers']],
               G['netstats'])


if '__main__' == __name__:
    parser = optparse.OptionParser()
    parser.add_option('--port', dest='port', type='int')
    parser.add_option('--servers', dest='servers', type='string')
    parser.add_option('--size', dest='size', type='int', default=1073741824)
    parser.add_option('--cmd', dest='cmd', type='string')
    parser.add_option('--key', dest='key', type='string')
    parser.add_option('--version', dest='version', type='string')
    parser.add_option('--value', dest='value', type='string')
    opt, args = parser.parse_args()

    servers = list()
    if opt.servers:
        servers = set(map(lambda x: (socket.gethostbyname(x[0]), int(x[1])),
                          map(lambda x: x.split(':'),
                              opt.servers.split(','))))
    if opt.port:
        G = dict(netstats=dict(), peers=dict(), fd=None)
        lockr_server(servers, G)
    else:
        cli = Lockr(servers)

        if 'state' == opt.cmd:
            print(json.dumps(cli.get_state(), indent=4, sort_keys=True))
        elif 'put' == opt.cmd:
            doc = {opt.key: (opt.version, opt.value)}
            print(struct.unpack('!B', cli.put(doc))[0])
        elif 'get' == opt.cmd:
            for k, v in cli.get([opt.key]).iteritems():
                print('{0}: {1} {2}'.format(k, v[0], v[1]))
                
